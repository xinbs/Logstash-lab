input {
  http {
    port => 15515
    additional_codecs => { "application/json" => "json" }
    # text/plain 会落在 [message] 字段
  }
}

# 自动设置 metadata type 为固定值 "test" (为了兼容现有逻辑)
filter {
  mutate {
    add_field => { "[@metadata][type]" => "test" }
  }
}

### !!! Web 会把下面 filter {...} 整块替换 !!!
filter {
    if "test" == [@metadata][type] {
        mutate {
        id => "opszone_vpn_log_filter"         
        remove_field => ["event"]
        }
        # 设备到区域映射初始化（统一维护，后续 Ruby 代码复用）
        ruby {
        code => '
        event.set("[@metadata][dev_region_map]", {
        "SG-AT1-STO-R027-FW-01" => "opszone",
        "SG-AT1-STO-R027-FW-02" => "opszone",
        "SG-DRT2-STO-R020-FW-01" => "opszone",
        "SG-DRT2-STO-R020-FW-02" => "opszone"
        })
        '
        }

        # 检查是否存在logs数组，如果存在则进行拆分处理
        if [logs] {
        # 将logs数组拆分成单独的日志条目
        split {
        field => "logs"
        }

        # 将拆分后的单个日志条目的message字段复制到根级别
        if [logs][message] {
        mutate {
        copy => { "[logs][message]" => "message" }
        }
        }
        }

        # 使用grok解析日志头部信息
        grok {
        id => "grok_firewall_header"
        match => {
        # 匹配ISO8601格式的时间戳，后跟主机名和剩余消息
        "message" => "%{TIMESTAMP_ISO8601:syslog_timestamp}\s+%{DATA:syslog_hostname}\s+%{GREEDYDATA:grok_message}"
        }
        # 确保即使匹配失败也可以继续处理
        tag_on_failure => ["_grokparsefailure", "grok_firewall_header_failed"]
        }

        # 根据日志内容判断防火墙类型
        if [grok_message] =~ "devname=" {
        # Fortinet 防火墙日志处理 - 使用 Ruby 进行更精确的 KV 解析
        ruby {
        code => '
        grok_message = event.get("grok_message")
        if grok_message && !grok_message.empty?
        # 创建 data_parsed 哈希
        data_parsed = {}

        # 使用正则表达式匹配所有 key=value 对，支持值中包含空格和特殊字符
        # 匹配模式：key=value，其中 value 可以是引号包围的字符串或者到下一个 key= 之前的内容
        pairs = grok_message.scan(/(\w+)=(?:"([^"]*)"|(["\s][^=]*?))(?=\s+\w+=|$)/)

        pairs.each do |match|
        key = match[0]
        # value 可能在 match[1]（引号内）或 match[2]（无引号）
        value = match[1] || match[2]
        if value
        data_parsed[key] = value.strip
        end
        end

        # 将解析结果设置到事件中
        event.set("data_parsed", data_parsed)

        # 设置设备相关字段
        devname = data_parsed["devname"]
        if devname && !devname.empty?
        event.set("equipment_name", devname)
        event.set("log_source_device", "Fortinet Opszone VPN @ #{devname}")
        else
        event.set("equipment_name", "unknown")
        event.set("log_source_device", "Fortinet Opszone VPN @ unknown")
        end
        event.set("__source", "fortinet_opszone_vpn")
        else
        # 如果 grok_message 为空，设置默认值
        event.set("equipment_name", "unknown")
        event.set("log_source_device", "Fortinet Opszone VPN @ unknown")
        event.set("__source", "fortinet_opszone_vpn")
        event.set("parse_error", "Empty grok_message")
        end
        '
        }

        mutate {
        remove_field => ["grok_message"]
        }
        # Fortinet：KV解析完成后进行区域判断
        ruby {
        code => '
        dev_region_map = event.get("[@metadata][dev_region_map]") || {}
        equipment_name = event.get("equipment_name")
        if equipment_name && !equipment_name.empty?
        region = dev_region_map[equipment_name]
        if region
        event.set("__region", region)
        else
        # 如果设备不在映射表中，直接丢弃该事件
        event.cancel()
        end
        else
        event.cancel()  # 丢弃 equipment_name 为空的事件
        end
        '
        }

        } else {
        # Palo Alto 防火墙日志处理
        # 先设置设备信息，随后进行区域判断（提前过滤无效设备）
        mutate {
        add_field => {
        "equipment_name" => "%{[syslog_hostname]}"
        "log_source_device" => "Palo Alto Opszone VPN @ %{[syslog_hostname]}"
        "__source" => "palo_alto_opszone_vpn"
        }
        }
        # Palo Alto：设备名设置后进行区域判断
        ruby {
        code => '
        dev_region_map = event.get("[@metadata][dev_region_map]") || {}
        equipment_name = event.get("equipment_name")
        if equipment_name && !equipment_name.empty?
        region = dev_region_map[equipment_name]
        if region
        event.set("__region", region)
        else
        # 如果设备不在映射表中，直接丢弃该事件
        event.cancel()
        end
        else
        event.cancel()  # 丢弃 equipment_name 为空的事件
        end
        '
        }
        # 仅在区域判断成功后再进行 CSV 解析和字段清理，避免不必要的开销
        if [__region] {
        # 解析CSV部分
        csv {
        source => "grok_message"
        target => "data_parsed"
        separator => ","
        autogenerate_column_names => true
        }
        mutate {
        remove_field => ["grok_message"]
        }
        }

        # 解析认证相关的日志字段
        if [data_parsed][column4] == "SYSTEM" and [data_parsed][column5] == "auth" {
        # 处理认证成功的情况
        if [data_parsed][column9] == "auth-success" {
        grok {
        id => "grok_auth_success"
        match => {
        "[data_parsed][column15]" => [
        "authenticated for user '%{DATA:auth_user}'\..*auth profile '%{DATA:auth_profile}'.*server profile '%{DATA:server_profile}'.*server address '%{IP:server_address}'.*auth protocol '%{DATA:auth_protocol}'.*admin role '%{DATA:admin_role}'.*From: %{IP:from_ip}\.",
        "Admin %{DATA:auth_user} account has been restored - lockout timer expired\.",
        "authenticated for user '%{DATA:auth_user}'\.?\s*From: %{IP:from_ip}\."
        ]
        }
        tag_on_failure => ["_grokparsefailure_auth_success"]
        }
        }
        # 处理认证失败的情况  
        else if [data_parsed][column9] == "auth-fail" {
        grok {
        id => "grok_auth_fail"
        match => {
        "[data_parsed][column15]" => [
        "failed authentication for user '%{DATA:user_name}'.*auth profile '%{DATA:auth_profile}', vsys '%{DATA:vsys}', server profile '%{DATA:server_profile}', server address '%{IP:dst_ip}', auth protocol '%{DATA:auth_protocol}', From: %{IP:src_ip}\.",
        "failed authentication for user '%{DATA:auth_user}'.*Reason: %{DATA:auth_reason}.*auth profile '%{DATA:auth_profile}'.*server profile '%{DATA:server_profile}'.*server address '%{IP:server_address}'.*auth protocol '%{DATA:auth_protocol}'.*From: %{IP:from_ip}\.",
        "failed authentication for user '%{DATA:user_name}'\.\s*Reason: %{GREEDYDATA:auth_reason} From: %{IP:src_ip}\."
        ]
        }
        tag_on_failure => ["_grokparsefailure_auth_fail"]
        }
        }
        }

        }

        # 如果来源是logs数组，保留一些元数据信息
        if [logs][sequence] {
        mutate {
        copy => {
        "[logs][sequence]" => "sequence"
        "[logs][severity]" => "severity"
        "[logs][timestamp]" => "original_timestamp"
        "[logs][trace_id]" => "trace_id"
        }
        }
        }
    }
}

output {
  file {
    path => "/data/out/events.ndjson"
    codec => json_lines
  }
  stdout { codec => rubydebug }
}